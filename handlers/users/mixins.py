import requests
from aiogram.dispatcher import FSMContext

from aiogram.utils.exceptions import MessageToDeleteNotFound

from data.config import API_CORE, user, password
from keyboards.inline.callback_data import update_cd
from loader import bot
import asyncio
from typing import Union
from aiogram import types
from aiogram.dispatcher.middlewares import BaseMiddleware
from aiogram.dispatcher.handler import CancelHandler


# –¥–ª—è –ø—Ä–∏–Ω—ë–º–∞ –∞–ª—å–±–æ–º–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –≤ –æ–¥–Ω–æ–º —Ö–µ–Ω–¥–ª–µ—Ä–µ
class AlbumMiddleware(BaseMiddleware):
    album_data: dict = {}

    def __init__(self, latency: Union[int, float] = 0.01):
        self.latency = latency
        super().__init__()

    async def on_process_message(self, message: types.Message, data: dict):
        if not message.media_group_id:
            return

        try:
            self.album_data[message.media_group_id].append(message)
            raise CancelHandler()
        except KeyError:
            self.album_data[message.media_group_id] = [message]
            await asyncio.sleep(self.latency)

            message.conf["is_last"] = True
            data["album"] = self.album_data[message.media_group_id]

    async def on_post_process_message(self, message: types.Message, result: dict, data: dict):
        if message.media_group_id and message.conf.get("is_last"):
            del self.album_data[message.media_group_id]


# –ó–∞–ø—Ä–æ—Å –≤—ã–±–æ—Ä–∫–∏ –ø–æ –º–æ–¥–µ–ª–∏ –∏–ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É url
def get_queryset(model=None, custom_url=False):
    url = API_CORE
    if model:
        url = API_CORE + f'{model}/'
    if custom_url:
        url = custom_url
    print(url)
    response = requests.get(url=url)
    data = response.json()
    return data


def refactor_related_data(data):
    res, i = '', 0
    for obj in data:
        i += 1
        if i == len(data):
            res += f'{obj["title"]}'
        else:
            res += f'{obj["title"]},'
    return res


# –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –Ω–∞–≤–∏–≥–∞—Ü–∏–∏. –ü–µ—Ä–µ—Ö–æ–¥ –∫ —Å–ª–µ–¥. –∏–ª–∏ –ø—Ä–µ–¥. —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º –≤—ã–±–æ—Ä–∫–∏
def create_store_navigation(next_data, previous_data):
    navigation = []
    if previous_data:
        previous_data = previous_data.replace(API_CORE, 'pag=')
        navigation.append(types.InlineKeyboardButton(text=f'‚¨ÖÔ∏è',
                                                     callback_data=previous_data))
    if next_data:
        next_data = next_data.replace(API_CORE, 'pag=')
        navigation.append(types.InlineKeyboardButton(text=f'‚û°Ô∏è',
                                                     callback_data=next_data))
    return types.InlineKeyboardMarkup(inline_keyboard=[navigation])


# –§—É–Ω–∫—Ü–∏—è –∏–∑—ä—è—Ç–∏—è –¥–∞–Ω–Ω—ã—Ö –æ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏—è—Ö –∏–∑ state
async def get_previous_message_data(state: FSMContext):
    data = await state.get_data()
    try:
        return data['sent_messages']
    except KeyError:
        return 0


# –£–¥–∞–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π
async def mess_delete(state: FSMContext, chat_id):
    messages = await get_previous_message_data(state)
    if not messages:
        return 0
    for message_id in messages:
        try:
            await bot.delete_message(chat_id=chat_id, message_id=message_id)
        except MessageToDeleteNotFound:
            pass
    await state.update_data(sent_messages=None)


# –í—ã–¥–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –≤—ã–±–æ—Ä–∞ –æ–¥–Ω–æ–π –∏–∑ CRUD –æ–ø–µ—Ä–∞—Ü–∏–π —Å –º–æ–¥–µ–ª—å—é
def get_crud_menu(prefix):
    read_title = "–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ"
    if prefix == "ITEM":
        read_title = "–ù–∞–π—Ç–∏ —Ç–æ–≤–∞—Ä"
    markup = types.InlineKeyboardMarkup(
        inline_keyboard=[
            [types.InlineKeyboardButton(text='–°–æ–∑–¥–∞—Ç—å',
                                        callback_data=f'{prefix}_create')],
            [types.InlineKeyboardButton(text=read_title,
                                        callback_data=f'{prefix}_read')],
            [types.InlineKeyboardButton(text='–ò–∑–º–µ–Ω–∏—Ç—å',
                                        callback_data=f'{prefix}_update')],
            [types.InlineKeyboardButton(text='–£–¥–∞–ª–∏—Ç—å',
                                        callback_data=f'{prefix}_delete')]
        ]
    )

    return markup


# –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ id –≤ —Å—Ç—Ä–æ–∫—É –∏–∑ –Ω–∞–∑–≤–∞–Ω–∏–π —Å–æ–æ—Ç–≤–µ—Å—Ç–≤—É—é—â–∏—Ö —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ –º–æ–¥–µ–ª–µ–π
def refactor_list_of_tuples_to_string(data, model: str):
    res = ''
    for element in data:
        url = API_CORE + f'{model}/{element}/'
        qs = get_queryset(model, url)
        try:
            res += qs['title'] + ', '
        except KeyError:
            return 0
    return res[:-2]


# –°–æ–∑–¥–∞–µ—Ç —Ç–µ–∫—Å—Ç –ø—Ä–µ–≤—å—é –∫–∞—Ä—Ç–æ—á–∫–∏ —Ç–æ–≤–∞—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–∑–¥–∞–µ—Ç —é–∑–µ—Ä
async def get_preview_data(state):
    data = await state.get_data()
    quality = ''
    if data['quality'] == 1:
        quality = 'Top quality'
    if data['quality'] == 2:
        quality = 'High quality - AAA +'
    if data['quality'] == 3:
        quality = '1: 1ü§©'
    gender = ''
    if data['gender'] == 1:
        gender = '–ú'
    if data['gender'] == 2:
        gender = '–ñ'
    if data['gender'] == 3:
        gender = '–£–Ω–∏—Å–µ–∫—Å'

    categories_string = refactor_list_of_tuples_to_string(data['categories'], 'category')
    brands_string = refactor_list_of_tuples_to_string(data['brands'], 'brand')
    if not categories_string or not brands_string:
        return 0, 0
    template = f"{data['title']}\n\n" \
               f"–ü–æ–ª: {gender}\n" \
               f"–ö–∞—á–µ—Å—Ç–≤–æ: {quality}\n" \
               f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: {categories_string}\n" \
               f"–ë—Ä—ç–Ω–¥: {brands_string}\n\n" \
               f"{data['description']}\n\n" \
               f"{data['price']} ‚ÇΩ"

    return data['photos'], template


def create_media_group(file_id_list):
    ids = []
    for file_id in file_id_list:
        response = requests.post(url=API_CORE + 'media_group/', data={'file_id': file_id})
        if response.status_code == 201:
            ids.append(response.json()['id'])
    return ids


# –ü–µ—Ä–µ–Ω–æ—Å —à–∞–±–ª–æ–Ω–∞ —Ç–æ–≤–∞—Ä–∞ –≤ api
async def send_template_to_api(state: FSMContext):
    data = await state.get_data()
    print(data)
    photos = create_media_group(data['photos'])
    data = {
        "title": data['title'],
        "description": data['description'],
        "gender": data['gender'],
        "quality": data['quality'],
        "price": data['price'],
        "category": data['categories'],
        "brand": data['brands'],
        "media_group": photos
    }
    response = requests.post(url=API_CORE + 'item/', data=data)
    if response.status_code == 201:
        return response.json()['id']
    return False


# –§—É–Ω–∫—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤
async def delete_model(call, pk, model):
    response = requests.delete(API_CORE + f'{model}/{pk}/')
    if response.status_code == 204:
        return await bot.send_message(call.from_user.id, '–û–±—ä–∫—Ç —É–¥–∞–ª–µ–Ω.')
    else:
        return await bot.send_message(call.from_user.id, '–û—à–∏–±–∫–∞. –û–±—ä–µ–∫—Ç –Ω–µ –±—ã–ª —É–¥–∞–ª–µ–Ω')


def get_auth_token():
    data = {
        "username": user,
        "password": password
    }
    response = requests.post(url=API_CORE + 'auth/', data=data)
    result = 0
    if response.status_code == 200:
        result = response.json()['token']
    return result


def add_new_admin(telegram_id):
    token = get_auth_token()
    headers = {"Authorization": f"Token {token}"}
    if token:
        response = requests.get(url=API_CORE + f"telegram-user/?telegram_id={telegram_id}",
                                headers=headers)
        pk = 0
        if response.status_code == 200:
            if response.json():
                pk = response.json()[0]['id']
        if not pk:
            response = requests.post(url=API_CORE + 'telegram-user/', headers=headers,
                                     data={'telegram_id': telegram_id, "is_staff": True})
            if response.status_code == 201:
                return 1
        else:
            response = requests.patch(url=API_CORE + f"telegram-user/{pk}/",
                                      headers=headers, data={"is_staff": True})
            if response.status_code == 200:
                if response.json()['is_staff']:
                    return 1
    return 0


def get_model_fields_markup(pk, model):
    response = requests.get(url=API_CORE + f"{model}/{pk}/")
    if not response.status_code == 200:
        return 0
    if not response.json():
        return 0
    buttons = []
    print(response.json())
    for field, value in response.json().items():
        if field == 'id' or field == 'subscribers':
            continue
        buttons.append([types.InlineKeyboardButton(text=f'{field}',
                                                   callback_data=update_cd.new(field=field))])

    return types.InlineKeyboardMarkup(inline_keyboard=buttons)


def get_admin_list_text():
    token = get_auth_token()
    if token:
        response = requests.get(url=API_CORE + 'telegram-user/?is_staff=1', headers={"Authorization": f"Token {token}"})
        if response.status_code == 200:
            data = response.json()
            text = '–°–ø–∏—Å–æ–∫ –ê–¥–º–∏–Ω–æ–≤\nID'
            for admin in data:
                text += f"\n{admin['telegram_id']}"
            return text
    return 0


# –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
def admin_auth(telegram_id):
    token = get_auth_token()
    response = requests.get(url=API_CORE + f'telegram-user/?telegram_id={telegram_id}&is_staff=1',
                            headers={"Authorization": f"Token {token}"})
    if response.status_code == 200:
        return response.json()
    return 0


def delete_admin(telegram_id):
    token = get_auth_token()
    response = requests.get(url=API_CORE + f'telegram-user/?telegram_id={telegram_id}&is_staff=1',
                            headers={"Authorization": f"Token {token}"})
    if response.status_code == 200:
        if not response.json():
            return 0
        pk = response.json()[0]['id']
        response = requests.patch(url=API_CORE + f'telegram-user/{pk}/',
                                  headers={"Authorization": f"Token {token}"},
                                  data={'is_staff': False})
        if response.status_code == 200:
            if not response.json()['is_staff']:
                return 1
    return 0


def create_telegram_user(telegram_id):
    token = get_auth_token()
    response = requests.post(API_CORE + "telegram-user/", headers={"Authorization": f"Token {token}"},
                             data={"telegram_id": telegram_id})
    if response.status_code == 201:
        return response.json()['id']
    return 0


def get_or_create_user(telegram_id):
    headers = {"Authorization": f"Token {get_auth_token()}"}
    response = requests.get(url=API_CORE + f"telegram-user/?telegram_id={telegram_id}",
                            headers=headers)
    if response.status_code == 200:
        if response.json():
            pk = response.json()[0]['id']
        else:
            pk = create_telegram_user(telegram_id)
            if not pk:
                return 0
    else:
        return 0
    return pk


def get_item_card_markup(fav_button_title, fav_cd,
                         item_id: int, previous_message):
    favourites_button = [types.InlineKeyboardButton(text=fav_button_title,
                                                    callback_data=fav_cd.new(
                                                        item_id=item_id,
                                                        previous_message=previous_message
                                                    ))]

    markup = types.InlineKeyboardMarkup(inline_keyboard=[favourites_button])
    return markup


async def create_navigation_block(call, next_url, previous_url, sent_messages):
    nav_markup = create_store_navigation(next_url, previous_url)
    if nav_markup['inline_keyboard'][0]:
        mess = await bot.send_message(call.from_user.id, f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç—Ä–µ–ª–∫–∏ –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º",
                                      reply_markup=nav_markup)
        sent_messages.append(mess.message_id)


def get_telegram_text(name):
    url = API_CORE + f'telegram-text/?name={name}'
    response = requests.get(url)
    if response.status_code != 200:
        return 0
    if response.json():
        text = response.json()[0]['body']
        if len(text) > 0:
            return text
        return 0
    return 0


def update_telegram_text(name, content):
    url = API_CORE + f'telegram-text/?name={name}'
    response = requests.get(url)
    if response.status_code != 200:
        return 0
    if response.json():
        pk = response.json()[0]['id']
        response = requests.patch(url=API_CORE + f"telegram-text/{pk}/", json={'body': content})
        if response.status_code == 200:
            if response.json()['body'] == content:
                return 1
        return 0
    else:
        response = requests.post(API_CORE + f"telegram-text/", json={"body": content, "name": name})
        if response.status_code == 201:
            return 1
    return 0
